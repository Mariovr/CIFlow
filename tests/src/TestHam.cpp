// CIFlow is a very flexible configuration interaction program
// Copyright (C) Ghent University 2014-2015
//
// This file is part of CIFlow.
//
// CIFlow is developed by Mario Van Raemdonck <mario.vanraemdonck@ugent.be>
// a member of the Ghent Quantum Chemistry Group (Ghent University).
// See also : http://www.quantum.ugent.be
//
// At this moment CIFlow is not yet distributed.
// However this might change in the future in the hope that
// it will be useful to someone.
//
// For now you have to ask the main author for permission.
//
//--
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE TestHam
#include <boost/test/unit_test.hpp>
#include <iostream>
#include <fstream>
#include "Hamiltonian.h"
#include "Permutator.h"
#include "CIMethod.h"
#include "UnitaryMatrix.h"
#include "OrbitalTransform.h"
#include "SimulatedAnnealing.h"

void orb_opt( CIMethod * cim){
    SimulatedAnnealing orbopt(cim  , 0.4 , 0.99 , 1.4 , 0.999);
    orbopt.run_multiple(4, false); //put true when you want to save the optimal unitary transformation.
    std::cout  << "Optimized energy with simulated annealing: " << orbopt.get_opt_ci_energy() << std::endl;
}

BOOST_AUTO_TEST_CASE( test_ao_so_mo_results)
{
  
    //Read in Hamiltonian in MO.
    Hamiltonian * ham = new Hamiltonian("../data/beh2_sto3g_1_5.dat");
    DOCI * cim = new DOCI(ham);
    cim->solve();
    BOOST_CHECK_CLOSE(-15.225362047972723 , cim->get_ci_energy() , pow(10,-10));
    ham->save();
    delete ham;
    
    //Load Ham back in but now from hdf5 format.
    Hamiltonian * ham2 = new Hamiltonian("hambeh2_sto3g_1_5.h5");
    BOOST_CHECK_CLOSE(7. , ham2->getL() , pow(10,-10));
    BOOST_CHECK_CLOSE(3. , ham2->getnup() , pow(10,-10));
    cim->set_ham(ham2);
    cim->solve();
    BOOST_CHECK_CLOSE(-15.225362047972723 , cim->get_ci_energy() , pow(10,-10));
    ham2->save_file();
    delete ham2;
    
    //Load Ham back in but now from textfile format generated by hamiltonian.
    ham2 = new Hamiltonian("hamhambeh2_sto3g_1_5.dat");
    BOOST_CHECK_CLOSE(7. , ham2->getL() , pow(10,-10));
    BOOST_CHECK_CLOSE(3. , ham2->getnup() , pow(10,-10));
    cim->set_ham(ham2);
    cim->solve();
    BOOST_CHECK_CLOSE(-15.225362047972723 , cim->get_ci_energy() , pow(10,-10));
    delete ham2;

    //Check so and mo integral file interaction. REMARK: unit is not Unitary because of the overlap matrix. This goes from symmetric orthogonalized AO to mo
    ham2 = new Hamiltonian("../data/atomicintegralsorthonbeh2_sto3g.h5");
    ham = new Hamiltonian("../data/atomicintegralsorthonbeh2_sto3g.h5");
    cim->set_ham(ham2);
    cim->solve();
    std::cout << "E of integralsorthon.h5: " << cim->get_ci_energy() <<std::endl; 
    SimulatedAnnealing * sim_anneal = new SimulatedAnnealing(cim  , 0.1 , 0.99 , 1.3 , 0.999 );
    sim_anneal->run_multiple(3, false);
    std::cout << "E after simulated annealing on atomicintegralsorthon.h5 : " << sim_anneal->get_opt_ci_energy() << "  should be lower than -15.328" << std::endl; 
    BOOST_CHECK_GE(-15.328, sim_anneal->get_opt_ci_energy() );
    sim_anneal->get_back_original_ham();
    delete sim_anneal;
    OrbitalTransform * orbtrans = new OrbitalTransform(ham2);
    //orb_opt( cim); //Remark Changes Hamiltonian in cim and ham2.
    UnitaryMatrix unit =orbtrans->get_unitary();
    unit.loadU("../data/unitary-moorthon.h5");
    unit.CheckDeviationFromUnitary();
    unit.print_unitary(std::cout);
    //std::ofstream file("unitary.dat");
    //unit.print_unitary(file);
    //file.close();
    //unit.load_unitary("unitary.dat");    
    //unit.print_unitary(std::cout);
    orbtrans->set_unitary(unit);
    orbtrans->fillHamCI(*ham); //Transformed ham from so to mo. Should give same doci energy.
    cim->set_ham(ham);
    cim->solve();
    std::cout << "E_after orthogonal atomic orbitals to mo transformation: " << cim->get_ci_energy() <<std::endl; 
    BOOST_CHECK_CLOSE(-15.225362047972723 , cim->get_ci_energy() , pow(10,-10));
    delete ham2;

    //REMARK: unit is not Unitary because of the overlap matrix. this goes from ao to mo
    ham2 = new Hamiltonian("../data/atomicintegralsbeh2_sto3g.h5");
    cim->set_ham(ham2);
    cim->solve();
    std::cout << "E of integrals.h5: " << cim->get_ci_energy() <<std::endl; 
    orbtrans->set_ham(ham2);
    //orb_opt( cim);//Remark Changes Hamiltonian in cim and ham2. Therefore put this always after we set the ham of orbitaltransform.
    unit.load_unitary("../data/unitary-mounit_ao_to_mo.txt");
    //unit.CheckDeviationFromUnitary();
    orbtrans->set_unitary(unit);
    orbtrans->fillHamCI(*ham); //Transformed ham from so to mo. Should give same doci energy.
    cim->set_ham(ham);
    cim->solve();
    std::cout << "E_after atomic orbitals (with pointgroup symmetry) to mo transformation: " << cim->get_ci_energy() <<std::endl; 
    BOOST_CHECK_CLOSE(-15.225362047972723 , cim->get_ci_energy() , pow(10,-10));
    delete orbtrans;
    delete cim;
    delete ham2;
    delete ham;
}

